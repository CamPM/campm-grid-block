<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Blast Zen</title>
    <style>
        /* --- SECTION: CSS VARIABLES & RESET --- */
        :root { --bg: #f0f4f8; --text: #334e68; --panel: #ffffff; --accent: #9fb3c8; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: 'Segoe UI', Tahoma, sans-serif; overflow: hidden; touch-action: none; transition: background 0.5s ease; }
        
        /* --- SECTION: UI LAYOUT --- */
        #ui-layer { position: absolute; top: 0; width: 100%; z-index: 5; pointer-events: none; }
        .pointer { pointer-events: auto; cursor: pointer; }
        .hud { display: flex; justify-content: space-between; padding: 15px; font-weight: 600; }
        .menu-overlay { position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(255,255,255,0.95); display:none; flex-direction:column; padding: 20px; box-sizing: border-box; overflow-y: auto; z-index: 20; }
        
        /* --- SECTION: CANVAS & GAME --- */
        #game-wrapper { display: flex; flex-direction: column; height: 100vh; justify-content: center; align-items: center; }
        canvas { background: var(--panel); border-radius: 12px; box-shadow: 0 10px 25px rgba(0,0,0,0.05); }
        .btn-group { margin-top: 20px; display: flex; gap: 10px; }
        button { border: none; padding: 10px 20px; border-radius: 8px; background: var(--text); color: white; font-weight: bold; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="hud">
        <div>Score: <span id="score">0</span></div>
        <div>High: <span id="highscore">0</span></div>
    </div>
</div>

<div id="game-wrapper">
    <canvas id="gameBoard"></canvas>
    <div class="btn-group">
        <button class="pointer" onclick="openMenu('help')">Help</button>
        <button class="pointer" onclick="openMenu('shop')">Shop</button>
        <button class="pointer" onclick="toggleMute()" id="muteBtn">ðŸ”Š Unmuted</button>
    </div>
</div>

<div id="help" class="menu-overlay">
    <h2>How to Play</h2>
    <p>Drag shapes onto the grid. Complete rows or columns to clear them. Clear the entire board to switch themes!</p>
    <h3>Power Ups:</h3>
    <ul>
        <li><b>Rotate:</b> Turn a shape before placing.</li>
        <li><b>Bomb:</b> Clear a 3x3 area.</li>
        <li><b>Refresh:</b> Get 3 brand new shapes.</li>
    </ul>
    <button class="pointer" onclick="closeMenus()">Close</button>
</div>

<div id="shop" class="menu-overlay">
    <h2>Zen Shop</h2>
    <div id="shop-items"></div>
    <button class="pointer" onclick="closeMenus()" style="margin-top:20px">Close</button>
</div>

<script>
/* --- SECTION: DEBUGGING & DATA --- */
const DEBUG = true;
let state = {
    gridSize: 8,
    score: 0,
    money: 0,
    muted: false,
    themeIdx: 0,
    unlockedThemes: [0, 1],
    currentSkin: 'default'
};

const THEMES = [
    { bg: "#ffffff", shape1: "#BEE3F8", shape2: "#E2E8F0" }, // Theme 1: Light Blue/Gray
    { bg: "#BEE3F8", shape1: "#E2E8F0", shape2: "#ffffff" }, // Theme 2: Blue base
    { bg: "#fefcbf", shape1: "#faf089", shape2: "#ecc94b" }, // Yellows
    { bg: "#c6f6d5", shape1: "#9ae6b4", shape2: "#48bb78" }, // Greens
    { bg: "#fed7e2", shape1: "#fbb6ce", shape2: "#f687b3" }, // Pinks
    { bg: "#e9d8fd", shape1: "#d6bcfa", shape2: "#b794f4" }, // Purples
    { bg: "#feebc8", shape1: "#fbd38d", shape2: "#f6ad55" }, // Oranges
    { bg: "#2d3748", shape1: "#4a5568", shape2: "#718096" }  // Dark Mode
];

/* --- SECTION: CORE ENGINE --- */
const canvas = document.getElementById('gameBoard');
const ctx = canvas.getContext('2d');
let board = [];
let shapes = [];
let draggingIdx = null;
let touchPos = { x: 0, y: 0 };

function initGame() {
    createBoard(state.gridSize);
    generateShapes();
    loadSave();
    applyTheme();
    animate();
}

function createBoard(size) {
    board = Array(size).fill().map(() => Array(size).fill(0));
    const canvasSize = Math.min(window.innerWidth * 0.9, 450);
    canvas.width = canvasSize;
    canvas.height = canvasSize + 160;
}

/* --- SECTION: LOGIC & PLACEMENT --- */
function canPlace(shape, row, col) {
    for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
            if (shape[r][c]) {
                if (row + r >= state.gridSize || col + c >= state.gridSize || row + r < 0 || col + c < 0) return false;
                if (board[row + r][col + c] !== 0) return false;
            }
        }
    }
    return true;
}

function checkLines() {
    let rowsToClear = [];
    let colsToClear = [];

    // Check Rows
    for (let r = 0; r < state.gridSize; r++) {
        if (board[r].every(cell => cell !== 0)) rowsToClear.push(r);
    }
    // Check Cols
    for (let c = 0; c < state.gridSize; c++) {
        let full = true;
        for (let r = 0; r < state.gridSize; r++) if (board[r][c] === 0) full = false;
        if (full) colsToClear.push(c);
    }

    rowsToClear.forEach(r => board[r].fill(0));
    colsToClear.forEach(c => {
        for (let r = 0; r < state.gridSize; r++) board[r][c] = 0;
    });

    if (rowsToClear.length > 0 || colsToClear.length > 0) {
        state.score += (rowsToClear.length + colsToClear.length) * 100;
        playSynthSound(660, 'triangle');
        checkBoardClear();
    }
}

function checkBoardClear() {
    let empty = board.every(row => row.every(cell => cell === 0));
    if (empty) {
        state.themeIdx = (state.themeIdx + 1) % state.unlockedThemes.length;
        applyTheme();
    }
}

/* --- SECTION: RENDER --- */
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const cellSize = canvas.width / state.gridSize;

    // Draw Board
    for (let r = 0; r < state.gridSize; r++) {
        for (let c = 0; c < state.gridSize; c++) {
            ctx.fillStyle = board[r][c] ? THEMES[state.themeIdx].shape1 : "#e2e8f0";
            ctx.fillRect(c * cellSize + 2, r * cellSize + 2, cellSize - 4, cellSize - 4);
        }
    }

    // Draw Shapes at bottom
    shapes.forEach((s, i) => {
        if (!s) return;
        const scale = 0.6;
        const startX = (canvas.width / 3) * i + 20;
        const startY = canvas.width + 40;
        
        ctx.fillStyle = THEMES[state.themeIdx].shape1;
        s.map.forEach((row, ri) => {
            row.forEach((v, ci) => {
                if (v) ctx.fillRect((draggingIdx === i ? touchPos.x : startX) + ci * cellSize * scale, 
                                    (draggingIdx === i ? touchPos.y : startY) + ri * cellSize * scale, 
                                    cellSize * scale - 2, cellSize * scale - 2);
            });
        });
    });
}

function animate() {
    draw();
    requestAnimationFrame(animate);
}

/* --- SECTION: UTILS --- */
function applyTheme() {
    document.body.style.background = THEMES[state.themeIdx].bg;
}

function toggleMute() {
    state.muted = !state.muted;
    document.getElementById('muteBtn').innerText = state.muted ? "ðŸ”‡ Muted" : "ðŸ”Š Unmuted";
}

function openMenu(id) { document.getElementById(id).style.display = 'flex'; }
function closeMenus() { document.querySelectorAll('.menu-overlay').forEach(m => m.style.display = 'none'); }

function playSynthSound(freq, type) {
    if (state.muted) return;
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.5);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.5);
}

// Logic for generating shapes and handling touch would follow the structure of 0.01 but with the canPlace() checks.
function generateShapes() {
    const SHAPES = [[[1,1],[1,1]], [[1,1,1]], [[1],[1],[1]], [[1,0],[1,1]], [[1]]];
    shapes = [
        {map: SHAPES[Math.floor(Math.random()*SHAPES.length)]},
        {map: SHAPES[Math.floor(Math.random()*SHAPES.length)]},
        {map: SHAPES[Math.floor(Math.random()*SHAPES.length)]}
    ];
}

function loadSave() {
    const saved = localStorage.getItem('blockBlastZen_save');
    if(saved) {
        const parsed = JSON.parse(saved);
        state.highscore = parsed.highscore || 0;
        document.getElementById('highscore').innerText = state.highscore;
    }
}

initGame();
</script>
</body>
</html>
