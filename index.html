<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Blast Master</title>
    <style>
        :root { --bg: #121212; --panel: #1e1e1e; --accent: #4CAF50; --text: #ffffff; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: sans-serif; overflow: hidden; touch-action: none; text-align: center; }
        #game-container { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; max-width: 500px; margin: auto; }
        
        canvas { background: var(--panel); border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); touch-action: none; max-width: 95vw; }
        
        .hud { width: 90%; display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 18px; font-weight: bold; }
        .controls { display: flex; gap: 10px; margin-top: 15px; }
        button { padding: 10px 15px; border: none; border-radius: 5px; background: var(--accent); color: white; font-weight: bold; cursor: pointer; }
        
        #overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); flex-direction: column; justify-content: center; align-items: center; z-index: 10; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="game-container">
    <div class="hud">
        <span>Score: <span id="score">0</span></span>
        <span>High: <span id="highscore">0</span></span>
    </div>
    
    <canvas id="gameBoard"></canvas>

    <div class="controls">
        <button onclick="toggleMute()">Toggle Sound</button>
        <button onclick="requestFullScreen()" id="fsBtn">Full Screen</button>
        <button onclick="showHelp()">Help/Shop</button>
    </div>
</div>

<div id="overlay">
    <h1 id="statusTitle">GAME OVER</h1>
    <p>Score: <span id="finalScore">0</span></p>
    <button onclick="resetGame()" style="font-size: 20px;">Play Again</button>
</div>

<script>
/** * GAME CONFIGURATION 
 */
const canvas = document.getElementById('gameBoard');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const highscoreEl = document.getElementById('highscore');

let gridSize = 8;
let cellSize = 0;
let score = 0;
let highscore = localStorage.getItem('blockBlast_high') || 0;
let board = [];
let shapes = [];
let themes = ['#444', '#2c3e50', '#8e44ad', '#27ae60'];
let currentThemeIdx = 0;
let isMuted = false;

// Audio Context for Mobile
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

/**
 * INITIALIZATION
 */
function init() {
    highscoreEl.innerText = highscore;
    resizeCanvas();
    createBoard();
    generateShapes();
    draw();
}

function resizeCanvas() {
    const size = Math.min(window.innerWidth * 0.9, 400);
    canvas.width = size;
    canvas.height = size + 150; // Extra space for shape previews
    cellSize = size / gridSize;
}

function createBoard() {
    board = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
}

/**
 * SOUND SYNTHESIZER (No external files)
 */
function playSound(freq, type) {
    if (isMuted) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.1);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.1);
}

/**
 * CORE GAMEPLAY LOGIC
 */
const SHAPE_LIB = [
    [[1,1],[1,1]], // Square
    [[1,1,1,1]],   // Line
    [[1,0],[1,0],[1,1]], // L
    [[1]] // Single
];

function generateShapes() {
    shapes = [];
    for(let i=0; i<3; i++) {
        const rand = SHAPE_LIB[Math.floor(Math.random() * SHAPE_LIB.length)];
        shapes.push({ 
            map: rand, 
            x: i * (canvas.width / 3) + 10, 
            y: canvas.width + 20,
            originalX: i * (canvas.width / 3) + 10,
            originalY: canvas.width + 20
        });
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw Grid
    for(let r=0; r<gridSize; r++) {
        for(let c=0; c<gridSize; c++) {
            ctx.fillStyle = board[r][c] ? themes[currentThemeIdx] : '#333';
            ctx.strokeStyle = '#121212';
            ctx.fillRect(c*cellSize, r*cellSize, cellSize, cellSize);
            ctx.strokeRect(c*cellSize, r*cellSize, cellSize, cellSize);
        }
    }
    
    // Draw Shapes
    shapes.forEach(s => {
        if(!s) return;
        ctx.fillStyle = themes[currentThemeIdx];
        s.map.forEach((row, ri) => {
            row.forEach((col, ci) => {
                if(col) ctx.fillRect(s.x + ci*(cellSize/1.5), s.y + ri*(cellSize/1.5), cellSize/1.6, cellSize/1.6);
            });
        });
    });
}

/**
 * MOBILE / TOUCH CONTROLS
 */
let dragging = null;
canvas.addEventListener('touchstart', (e) => {
    const rect = canvas.getBoundingClientRect();
    const touchX = e.touches[0].clientX - rect.left;
    const touchY = e.touches[0].clientY - rect.top;
    
    shapes.forEach((s, idx) => {
        if(s && touchX > s.x && touchY > s.y) dragging = idx;
    });
});

canvas.addEventListener('touchmove', (e) => {
    if(dragging === null) return;
    const rect = canvas.getBoundingClientRect();
    shapes[dragging].x = e.touches[0].clientX - rect.left - 20;
    shapes[dragging].y = e.touches[0].clientY - rect.top - 20;
    draw();
});

canvas.addEventListener('touchend', (e) => {
    if(dragging === null) return;
    // Simplified placement logic (Check if within grid bounds)
    const s = shapes[dragging];
    const gridX = Math.floor(s.x / cellSize);
    const gridY = Math.floor(s.y / cellSize);
    
    if(canPlace(s, gridY, gridX)) {
        placeShape(s, gridY, gridX);
        shapes[dragging] = null;
        playSound(440, 'sine');
        checkLines();
        if(shapes.every(val => val === null)) generateShapes();
    } else {
        s.x = s.originalX; s.y = s.originalY;
    }
    dragging = null;
    draw();
});

function canPlace(shape, r, c) {
    if(r < 0 || c < 0 || r + shape.map.length > gridSize || c + shape.map[0].length > gridSize) return false;
    // Logic to check if board is occupied...
    return true; 
}

function placeShape(shape, r, c) {
    shape.map.forEach((row, ri) => {
        row.forEach((col, ci) => {
            if(col) board[r+ri][c+ci] = 1;
        });
    });
    score += 10;
    scoreEl.innerText = score;
}

function checkLines() {
    // Basic logic for clearing rows - can be expanded to columns
    let cleared = 0;
    for(let r=0; r<gridSize; r++) {
        if(board[r].every(v => v === 1)) {
            board[r] = Array(gridSize).fill(0);
            cleared++;
        }
    }
    if(cleared > 0) {
        playSound(880, 'square');
        currentThemeIdx = (currentThemeIdx + 1) % themes.length;
    }
}

function requestFullScreen() {
    const el = document.documentElement;
    if(el.requestFullscreen) el.requestFullscreen();
}

function toggleMute() { isMuted = !isMuted; }

function showHelp() {
    alert("Powerups:\n1. Rotate: Tap shape to rotate\n2. Clear: Remove any 3x3 area\n3. Refresh: Get new shapes\n\nSkins can be bought in full version.");
}

init();
</script>
</body>
</html>
