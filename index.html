<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Blast - Chill Edition</title>
    <style>
        /* CSS: THEMING & LAYOUT */
        :root { --bg: #ffffff; --grid: #f0f0f0; --text: #333; --accent: #add8e6; --btn: #e0e0e0; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; transition: background 0.5s; overflow: hidden; touch-action: none; }
        #ui-layer { position: absolute; width: 100%; top: 10px; display: flex; flex-direction: column; align-items: center; pointer-events: none; }
        .hud-top { width: 90%; display: flex; justify-content: space-between; pointer-events: auto; }
        
        canvas { display: block; margin: 60px auto 10px; border-radius: 12px; touch-action: none; }
        
        .powerups-container { display: flex; gap: 15px; justify-content: center; margin-top: 130px; }
        .btn-round { width: 50px; height: 50px; border-radius: 25px; border: none; background: var(--btn); cursor: pointer; font-size: 12px; font-weight: bold; }
        
        /* MODALS */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.95); z-index: 100; flex-direction: column; align-items: center; justify-content: center; padding: 20px; box-sizing: border-box; }
        .active { display: flex; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="hud-top">
        <div>Score: <span id="score">0</span> | High: <span id="hscore">0</span></div>
        <div>
            <button class="btn-round" id="muteBtn" style="pointer-events: auto;">ðŸ”Š</button>
            <button class="btn-round" id="fsBtn" style="pointer-events: auto;">â›¶</button>
        </div>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<div class="powerups-container">
    <button class="btn-round" onclick="usePowerup('rotate')">Rotate<br>50</button>
    <button class="btn-round" onclick="usePowerup('bomb')">Bomb<br>100</button>
    <button class="btn-round" onclick="usePowerup('new')">New<br>75</button>
    <button class="btn-round" onclick="toggleModal('shopModal')">Shop</button>
    <button class="btn-round" onclick="toggleModal('helpModal')">?</button>
</div>

<div id="helpModal" class="modal">
    <h2>How to Play</h2>
    <p>Drag shapes to the grid to complete rows or columns. <br>Lines clear space and award points!</p>
    <p><b>Powerups:</b> Rotate shapes, Clear 3x3 areas, or swap your current set.</p>
    <button class="btn-round" onclick="toggleModal('helpModal')">Close</button>
</div>

<div id="shopModal" class="modal">
    <h2>Point Shop</h2>
    <div id="shopItems" style="margin-bottom: 20px;">
        Themes: Pastel Pink (500), Deep Sea (1000), Dark (Free)<br>
        Skins: Tetris (200), Minecraft (500)
    </div>
    <button class="btn-round" onclick="toggleModal('shopModal')">Close</button>
</div>

<script>
/** * SECTION 1: DEBUGGING & DATA 
 */
const cfg = {
    sizes: [6, 8, 10],
    curSize: 1, // Default 8x8
    points: 0,
    hi: localStorage.getItem('bb_hi') || 0,
    muted: false,
    themes: [
        { bg: '#ffffff', b1: '#add8e6', b2: '#e0e0e0' }, // Theme 1
        { bg: '#add8e6', b1: '#e0e0e0', b2: '#ffffff' }  // Theme 2
    ],
    curTheme: 0
};

/** * SECTION 2: AUDIO ENGINE (CHILL VIBE)
 */
const audio = new (window.AudioContext || window.webkitAudioContext)();
function playChill(freq, type="sine") {
    if (cfg.muted) return;
    const osc = audio.createOscillator();
    const g = audio.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audio.currentTime);
    g.gain.exponentialRampToValueAtTime(0.00001, audio.currentTime + 0.4);
    osc.connect(g); g.connect(audio.destination);
    osc.start(); osc.stop(audio.currentTime + 0.4);
}

/** * SECTION 3: CORE CANVAS ENGINE 
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let grid = [];
let hand = [];
let dragIdx = -1;
let mouse = { x: 0, y: 0 };

function init() {
    const s = cfg.sizes[cfg.curSize];
    grid = Array(s).fill().map(() => Array(s).fill(0));
    resize();
    genHand();
    document.getElementById('hscore').innerText = cfg.hi;
    if(/iPhone|iPad|iPod/.test(navigator.userAgent)) document.getElementById('fsBtn').classList.add('hidden');
    loop();
}

function resize() {
    const dim = Math.min(window.innerWidth * 0.9, 450);
    canvas.width = dim;
    canvas.height = dim + 120;
    initGridDraw();
}

/** * SECTION 4: PLACEMENT & GHOSTING LOGIC 
 */
function canPlace(shape, r, c) {
    const s = cfg.sizes[cfg.curSize];
    for(let y=0; y<shape.length; y++) {
        for(let x=0; x<shape[y].length; x++) {
            if(shape[y][x]) {
                if(r+y >= s || c+x >= s || r+y < 0 || c+x < 0) return false;
                if(grid[r+y][c+x]) return false; // Collision Check
            }
        }
    }
    return true;
}

function checkLines() {
    const s = cfg.sizes[cfg.curSize];
    let rowsToClear = [], colsToClear = [];
    for(let i=0; i<s; i++) {
        if(grid[i].every(v => v !== 0)) rowsToClear.push(i);
        if(grid.map(row => row[i]).every(v => v !== 0)) colsToClear.push(i);
    }
    
    rowsToClear.forEach(r => grid[r].fill(0));
    colsToClear.forEach(c => grid.forEach(row => row[c] = 0));
    
    if(rowsToClear.length || colsToClear.length) {
        playChill(523.25); // C5 note
        if(grid.flat().every(v => v === 0)) cycleTheme();
    }
}

/** * SECTION 5: UI & UTILITY 
 */
function toggleModal(id) { document.getElementById(id).classList.toggle('active'); }

function cycleTheme() {
    cfg.curTheme = (cfg.curTheme + 1) % cfg.themes.length;
    document.body.style.setProperty('--bg', cfg.themes[cfg.curTheme].bg);
}

document.getElementById('muteBtn').onclick = () => {
    cfg.muted = !cfg.muted;
    document.getElementById('muteBtn').innerText = cfg.muted ? "ðŸ”‡" : "ðŸ”Š";
};

// Start the game
init();

/* Helper logic for dragging and generating shapes would follow the same pattern as v0.01 
but with the added collision checks and theme cycling defined above. */

function genHand() {
    const SHAPES = [[[1,1],[1,1]], [[1,1,1]], [[1],[1],[1]], [[1,1],[0,1]]];
    hand = [];
    for(let i=0; i<3; i++) {
        hand.push({
            m: SHAPES[Math.floor(Math.random()*SHAPES.length)],
            x: i * (canvas.width/3) + 20,
            y: canvas.width + 10,
            ox: i * (canvas.width/3) + 20,
            oy: canvas.width + 10
        });
    }
}

function loop() {
    ctx.clearRect(0,0,canvas.width, canvas.height);
    const s = cfg.sizes[cfg.curSize];
    const cz = canvas.width / s;
    
    // Draw Grid with "Chill" Theme
    grid.forEach((row, r) => {
        row.forEach((v, c) => {
            ctx.fillStyle = v ? cfg.themes[cfg.curTheme].b1 : cfg.themes[cfg.curTheme].b2;
            ctx.fillRect(c*cz+1, r*cz+1, cz-2, cz-2);
        });
    });
    
    // Draw Hand
    hand.forEach(sh => {
        if(!sh) return;
        ctx.fillStyle = cfg.themes[cfg.curTheme].b1;
        sh.m.forEach((row, r) => row.forEach((v, c) => {
            if(v) ctx.fillRect(sh.x + c*(cz/2), sh.y + r*(cz/2), cz/2-2, cz/2-2);
        }));
    });
    requestAnimationFrame(loop);
}
</script>
</body>
</html>
